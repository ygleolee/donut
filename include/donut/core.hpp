#pragma once

#include "donut/geometry.hpp"
#include "donut/types.hpp"

// key ideas:
// 1. monitor is XY-plane, Z-axis comes out of screen, origin at center of screen.
// 2. the object is always located in the square [-100, 100] x [-100, 100]
// 3. 'canvas' is the screen (XY-plane) divided into pixels, depending on the resolution.

// TODO: select brightness depending on terminal resolution
// TODO: change points generated by shapes.cpp depending on terminal resolution
// TODO: customizable rotate speed
// TODO: edit each necessary pixel instead of re-printing everything?
// TODO: cache the data points instead of calculating on the fly
// TODO: light blocked by other parts of the object ?!

namespace donut::core {

void rotate_shape(ves& points, ves& normals, vec degrees);

void draw(
  grd& canvas,  // canvas to draw pixels onto
  ves& points,                // points in R^3 of the shape
  ves& normals,               // normal vectors of each corresponding point
  dbl viewer,                              // z value of viewer
  vec light,                               // vector if PARALLEL, point in R^3 if POINT
  donut::geometry::light_type light_src_type                // PARALLEL or POINT
);

// global variables defined in parameter.cpp for users to control
// extern dbl viewer;
// extern vec rotation;
// extern donut::geometry::light_type light_src_type;
// extern vec light_parallel;
// extern vec light_point;
// extern dbl fps;

// fixed camera, light, viewer, rotation speed
void animate_simple(
  ves points,    // points in R^3 of the shape
  ves& normals,  // normal vectors of each corresponding point
  std::array<dbl, 3> degrees, // angles to rotate about each axis every frame (in radian)
  dbl viewer,                 // z value of viewer
  vec light,                  // vector if PARALLEL, point in R^3 if POINT
  donut::geometry::light_type light_src_type,  // PARALLEL or POINT
  dbl interval                // interval between each frame
);

void animate(
  ves points,  // points in R^3 of the shape
  ves normals  // normal vectors of each corresponding point
);

}
